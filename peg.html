<html>
<body>
<script src = './devserver.js'></script>
<script>
function run(){

var LOG = 0

// GRAMMAR
var defGrammar = {
	Start   	:o=>o.zeroOrMore(o=>o.ws && o('\n')) && o.zeroOrMore(o=>o.Attribute || o.Statement || o.CommentLine),	
	IdChain     :o=>o.fold(o=>o.NotKeyword && o.Id && o.zeroOrMore(o=>o('.') && o.Id)),

	PrefId      :o=>o.empty(o=>o.zeroOrOne(o=>o('!')||o('-')||o('+')) && o.ws && o.IdChain, 1),

	Number      :o=>(o.zeroOrOne(o=>o('-')) && o.oneOrMore(o=>o('0', '9')) && o.zeroOrOne(o=>o('.') && o.oneOrMore(o=>o('0', '9')))),
	Boolean     :o=>o('true') || o('false'),

	DoLine      :o=>o('do:') && o.Statement,

	DoBlock		:o=>o('do') && o.ws && o.eat('\n') && o.Statements && o.ws && o('end'),

	Statements  :o=>o.zeroOrMore(o=>o.ws && o('\n')) && o.zeroOrMore(o=>o.not(o=>o.eat('end') || o.eat('else')) && (o.Statement || o.CommentLine)),

	Comment     :o=>o('#') && o.zeroOrMore(o=>o.inv('\n')),
	CommentLine :o=>o.ws && o.eat('\n') || o('#') && o.zeroOrMore(o=>o.inv('\n')) && o.eat('\n'),

	Arrow       :o=>(o.ws && o.Expression && o.ws && o('->') && o.zeroOrMore(o=>o.ws && o('\n') && o.ws) && (o.CallNoParen || o.Expression)),

	Statement	:o=>o.ws && o.group(o=>o.Arrow || o.CallNoParen || o.Expression || o.Comment) && o.zeroOrMore(o=>o.ws && o.Comment) && o.ws && o.eat('\n'),
	
	Attribute	:o=>o('@') && o.Id && o.rws && o.Expression && o.oneOrMore(o=>o.ws && o.eat('\n')),
	
	Expression  :o=>o.Assign || o.Logic || o.Math || o.ExprItem,
	ExprItem    :o=>o.fold(o=>o.CallParen || o.If || o.DoLine || o.DoBlock  || o.List || o.String || o.Atom || o.AttribRef || o.Number|| o.Boolean || o.PrefId),
	List 		:o=>o('[') && o.ws && o.zeroOrOne(o=>o.Expression) && o.zeroOrMore(o=>o.ws && o(',') && o.ws && o.Expression) && o.ws && o(']'),

	Label       :o=>o.NotKeyword && o.Id && o(':'),
	Atom        :o=>o(':') && o.Id,
	AttribRef   :o=>o('@') && o.Id,

	ParenArg    :o=>o.zeroOrOne(o=>o.Label && o.ws) && o.Expression,
	CallParen   :o=>o.IdChain && o.ws && o('(') && o.ws && o.zeroOrOne(o=>o.ParenArg) && o.zeroOrMore(o=>o.ws && o(',') && o.ws && o.ParenArg) && o.ws && o(')') && o.zeroOrOne(o=>o.ws && (o.DoLine || o.DoBlock )),

	NoParenArg  :o=>o.zeroOrOne(o=>o.Label && o.ws) && o.Expression,
	CallNoParen	:o=>o.IdChain && o.rws && o.NoParenArg && o.zeroOrMore(o=>( o.group(o=>o.ws && o(',') && o.ws) ||o.rws) && o.NoParenArg),
	
	ElseBlock: 	o=>o('do') && o.ws && o.eat('\n') && 
				o.Statements &&
				o.ws && o('else') && o.ws && o.eat('\n') &&
				o.Statements &&
				o.ws && o('end'),

	If: o=>o('if') && o.rws && o.Expression && o.rws && (o.ElseBlock || o.DoLine || o.DoBlock ),

	Assign		:o=>o.Id && o.ws && o.group(o=>o('+=')||o('-=')||o('/=')||o('*=')||o('=')) && o.ws && (o.CallNoParen || o.Expression),

	Logic   :o=>o.foldTwo(o=>o.Or),
	Or      :o=>o.fold(o=>o.And && o.zeroOrMore(o=>o.ws && o('||') && o.ws && o.And)),
	And     :o=>o.fold(o=>o.Cmp && o.zeroOrMore(o=>o.ws && o('&&') && o.ws && o.Cmp)),
	Cmp     :o=>o.fold(o=>o.LogicS && o.zeroOrOne(o=>o.ws && (o('<=') || o('<') || o('>=') || o('>') || o('!=') || o('==')) && o.ws && o.LogicS)),
	LogicS  :o=>o.fold(o=>o.ExprItem || o('(') && o.ws && o.Expression && o.ws && o(')')),

	Math    :o=>o.foldTwo(o=>o.Sum),
	Sum     :o=>o.fold(o=>o.Prod && o.zeroOrMore(o=>o.ws && (o('+') || o('-')) && o.ws  && o.Prod)),
	Prod    :o=>o.fold(o=>o.MathS && o.zeroOrMore(o=>o.ws && (o('*') || o('/')) && o.ws && o.MathS)),
	MathS   :o=>o.fold(o=>o.ExprItem || o('(') && o.ws && o.Expression && o.ws && o(')')),

	// optimized out:
	//Id	    :o=>o.not(o=>o('do') || o('end') || o('if')) && (o('a', 'z') || o('A', 'Z') || o('_')) && o.zeroOrMore(o=>o('a', 'z') || o('A', 'Z') || o('0', '9') || o('_')),
	//String  	:o=>o('"') && o.zeroOrMore(o=>o.inv('"')) && o('"'),

	// optimized getters
	_ws     :function() {
		var o = this
		var input = o.input
		while(o.pos < input.length){
			var ch = input.charCodeAt(o.pos)
			if(ch !== 32 && ch !== 9) break
			o.pos++
		}
		return true
	},
	_rws     :function() {
		var o = this
		var input = o.input
		var pos = o.pos
		while(o.pos < input.length){
			var ch = input.charCodeAt(o.pos)
			if(ch !== 32 && ch !== 9) break
			o.pos++
		}
		return pos !== o.pos
	},
	_NotKeyword : function(){
		var o = this
		var input = o.input
		var pos = o.pos
		var c1 = input.charCodeAt(o.pos)
		var c2 = input.charCodeAt(o.pos+1)
		var c3 = input.charCodeAt(o.pos+2)
		var c4 = input.charCodeAt(o.pos+3)
		var c5 = input.charCodeAt(o.pos+4)
		if(c1 == 100 && c2 == 111)  return false // do
		if(c1 == 105 && c2 == 102) return false //if
		if(c1 == 101 && c2 == 110 && c3 == 100) return false // end
		//if(c1 == 101 && c2 == 110 && c3 == 100) return false // else
		//if(c1 == 101 && c2 == 110 && c3 == 100) return false // true
		//if(c1 == 101 && c2 == 110 && c3 == 100) return false // false
		return true
	},
	_Id      :function() {
		var o = this
		var input = o.input
		var pos = o.pos
		var c1 = input.charCodeAt(o.pos)

		if(c1 >= 65 && c1 <=90 || c1 >= 97 && c1 <= 122 || c1 == 95){
			while(o.pos < input.length){
				c1 = input.charCodeAt(++o.pos)
				if(!(c1 >=48 && c1 <= 57 || c1 >= 65 && c1 <=90 || c1 >= 97 && c1 <= 122 || c1 == 95)){
					// make a node and add it.
					o.ast.n.push({
						type:'Id',
						value:input.slice(pos, o.pos), 
						start:pos, end:o.pos
					})
					if(LOG) _='Id:[' + input.slice(pos, o.pos) + ']' + input.slice(o.pos + 1)
					break
				}
			}
		}
		return pos !== o.pos
	},
	_String   :function() {
		var o = this
		var input = o.input
		var pos = o.pos
		var ch = input.charCodeAt(o.pos)
		if(ch == 34){
			while(o.pos < input.length){
				ch = input.charCodeAt(++o.pos)
				if(ch === 34){
					o.pos++
					o.ast.n.push({
						type:'String',
						value:input.slice(pos, o.pos), 
						start:pos, end:o.pos
					})
					if(LOG) _='String:[' + input.slice(pos, o.pos) + ']' + input.slice(o.pos + 1)
					return true
				}
			}
		}
		return false
	}
}

// Input form
var inputSource = document.getElementById('file').childNodes[1].nodeValue

function makeParser(rules) {
	
	function p(a, b, eat, inv) {
		var input = p.input
		if(p.pos > input.length) return false
		if(typeof b === 'string') { // range
			var c = input.charCodeAt(p.pos)
			var cin = c >= a.charCodeAt(0) && c <= b.charCodeAt(0)
			if(inv && !cin || !inv && cin) {
				if(!eat) p.ast.value += input.charAt(p.pos)
				if(LOG) _='[' + input.charAt(p.pos) + ']' + input.slice(p.pos + 1)
				p.pos++
				return true
			}
			if(LOG) _='!' + input.charAt(p.pos) + '!' + input.slice(p.pos + 1)
			return false
		}
		var s = ''
		for(var i = 0, pos = p.pos;i < a.length;i++,pos++){ // string match
			s += input.charAt(pos)
			var cin = input.charCodeAt(pos) !== a.charCodeAt(i)
			if(inv && !cin || !inv && cin) {
				if(LOG) _='!' + s + '!' + '('+a+')'+input.slice(p.pos + s.length)
				return false
			}
		}
		if(LOG) _='[' + s + ']' + input.slice(p.pos + s.length)
		
		if(!eat) p.ast.value += s
		if(pos > p.last) p.last = pos
		p.pos = pos
		return true
	}
	p.__defineSetter__('trace', function(value){
		console.log('TRACE',value)
		//debugger
	})
	p.eat = function(a, b) {
		return p(a, b, true)
	}
	
	p.inv = function(a, b) {
		return p(a, b, false, true)
	}
	
	p.parse = function(input) {
		p.memoize = {}
		p.input = input
		p.pos = 0
		p.last = 0
		var ast = p.ast = {n:[]}
		p.fail = []
		p.stack = []
		p.Start
		return ast.n[0]
	}
	
	p.fold = function(fn) {
		if(fn(p)) {
			if(p.ast.n.length < 2) return 0
			return true
		}
		return false
	}

	p.foldTwo = function(fn) {
		if(fn(p)) {
			var len = p.ast.n.length
			if(len < 2){
				if(len === 1){
					var n2 = p.ast.n[0].n
					if(!n2 || n2.length < 2) return false
				}
				return 0
			}
			return true
		}
		return false
	}

	p.empty = function(fn) {
		if(fn(p)) {
			if(p.ast.value.length == 0) return 0
			return true
		}
		return false
	}


	p.zeroOrMore = function(fn) { //zero or more
		while(1){
			var pos = p.pos
			if(!fn(p)){
				p.pos = pos
				break
			}
		}
		return true
	}
	
	p.oneOrMore = function(fn) { //one or more
		var c = 0
		while(1){
			var pos = p.pos
			if(!fn(p)){
				p.pos = pos
				break
			}
			c++
		}
		return c !== 0
	}
	
	p.zeroOrOne = function(fn) { //one or more
		var pos = p.pos
		if(!fn(p)){
			p.pos = pos
		}
		return true
	}
	
	p.not = function(fn, b) {
		var pos = p.pos, ret = fn(p)
		p.pos = pos
		return !ret
	}
	
	p.and = function(fn, b) {
		var pos = p.pos, ret = fn(p)
		p.pos = pos
		return ret
	}
	
	p.group = function(fn) {
		var pos = p.pos, ret = fn(p)
		if(!ret) p.pos = pos
		return ret
	}

	for(var key in rules){
		if(key.charAt(0) === '_'){
			p.__defineGetter__(key.slice(1), rules[key])
		}
		else p.__defineGetter__(key, function(key) {
			
			var pos = p.pos

			var rule = rules[key]
			var parent = p.ast
			// lets check our memoize fn 
			
			// if we do the same item at the same spot, return it
			p.stack.push(key)

			var memo = p.memoize[pos]
			var mine = memo && memo[key]
			var ret
			if(!mine){
				mine = p.ast = {type:key, n:[], value:'', start:pos}
				ret = rule(p)
			}
			else{
				p.pos = mine.end
				ret = true
			}

			p.ast = parent

			if(ret === true) {
				var memo = p.memoize[mine.start] || (p.memoize[mine.start] = {})
				memo[key] = mine
				mine.end = p.pos
				parent.n.push(mine)
				parent[key] = mine
				p.stack.pop()
				return true
			}
			else if(ret === 0) {
				var sub = mine.n[0]
				if(sub) parent.n.push(mine.n[0])
				p.stack.pop()
				return true
			}
			p.fail.push(p.stack.join('/'))
			p.stack.pop()
			p.pos = pos
			return false
		}.bind(this, key))
	}
	
	return p
}
Error.stackTraceLimit=150
window.__defineSetter__('_', function(arg){
	var stack = new Error().stack || ''
	// lets collect the stack
	var st = stack.split('\n')
	var str = ''
	for(var i = 0; i < st.length; i++){
		var m = st[i].match(/at (\w+)/)
		if(m){
			if(defGrammar[m[1]]){
				str = m[1] + '>' + str
			}
		}
	}
	console.log(str + ': '+arg.replace(/\n/g, '\\n'))
})

var parser = makeParser(defGrammar)
var dt = Date.now()
var bench = false
if(bench){
	var dt = Date.now()
	for(var i = 0; i <100; i++){
		var ast = parser.parse(inputSource)
	}
	console.log("Performance per parse: "+((Date.now()-dt)/100)+"ms")
}

var ast = parser.parse(inputSource)

/*
var serializeAST = {
	indentChar:'   ',
	indent:'',
	'Name': function(node){
		return node.value
	},
	'String': function(node){
		return node.value 
	},
	'Say': function(node){
		var ret = 'say'
		var n = node.n
		for(var i = 0; i < n.length; i++){
			var arg = n[i]
			ret += ' ' + this[arg.type](arg)
		}
		return ret
	},
	'Statement' : function(node){
		var arg = node.n[0]
		return this[arg.type](arg)
	},
	'Block': function(node){
		var indent = this.indent
		this.indent += this.indentChar

		var ret ='do\n'
		var n = node.n
		for(var i = 0; i < n.length; i++){
			var stmt = n[i]
			ret += this.indent + this[stmt.type](stmt) + '\n'
		}
		this.indent = indent
		ret += indent + 'end\n'
		return ret
	},
	'Dialog':function(node){
		return 'Dialog ' + this.Name(node.Name) + ' ' + this.Block(node.Block)
	}
}*/

var out = ''
function dumpAst(node, d){
	out += '<span>'+Array(d).join('&nbsp&nbsp&nbsp') + node.type + ':' + node.value+'</span><br/>'
	if(node.n) for(let i = 0;i < node.n.length;i++){
		dumpAst(node.n[i], d + 1)
	}
}
out += '<span>---- AST -----</span><br/>'
dumpAst(ast, 0)
document.body.innerHTML = out


// lets modify the name of the dialog:
//ast.Dialog.Name.value = 'myDialog'
/*
document.body.innerHTML += '<span>----- Reserialized -----<br/>'+ serializeAST.Dialog(ast.Dialog).replace(/\n/g,'<br/>').replace(/ /g,'&nbsp;')+'</span>'
*/
}
document.addEventListener('DOMContentLoaded', run)
</script>
<div id='file2'>
<!--

if a == c do

end

-->
</div>
<div id='file'>
<!--
import "main"
import "helpers"

# Settings

@delay 1
@typing_indicator 1

# Common Entities

@yes learn(input: "yes|yep|sure", label: "Yes", return: :yes)
@no learn(input: "no|nope|nah", label: "No", return: :no)

# Common Dialogs

dialog main do
  location = ask "Please share your location", expecting: :location
  think 1.5
  laugh = ask "Did you laugh?", quick_replies: ["Yes", "No"], help_dialog: oops
  sleep 2 * 2
  image "https://www.domain.com/image.jpg"
  location [4.893414, 52.364909]
end

dialog button do
  buttons "What do you want to do next?" do
    "Open CNN" ->
      open "http://cnn.com"
    "Postback hi" ->
      postback "hi"
  end
end

# special for of blocks with only one statement. shows that blocks are just last parameter to functions in Elixir
dialog shortblock, do: say "hello"

dialog express do
  foo = 1
  remember foo
  forget foo
end

dialog logic do
  say "Let try out some logical thinking"
  
  say "156 + 234 ="
  say 156 + 234
  
  say "12 > 2 ?"
  say 12 > 2
  
  a = 1
  b = "1"
  c = 1.0
  d = "one"
  
  if a == b do
    say "1 is '1'"
  else
    say "1 is not '1'"
  end
  
  if a == c do
    say "1 is 1.0"
  else
    say "1 is not 1.0"
  end
  
  if a != d do
    say "1 is not one"
  else
    say "1 is one"
  end
  
  if a == c || a == d do
    say "Either 1 is 1.0 OR 1 is one"
  end
  
  if a == c && a == d do
    say "1 is 1.0 AND 1 is one"
  else
    say "Nope (1 is 1.0) AND (1 is one) are not both true"
  end
  
  # you can nest if else blocks for more fine grained "thinking"
  if a == c do
    say "1 is 1.0"
    if a == d do
      say "1 is one"
    else
      say "but 1 is not one"
    end
  else
    say "but 1 is not 1.0"
  end
  
  say "finished"
end

dialog trigger: "stop|quit|end|finish" do
  say "Ok I'll shut up now. Activate me again by saying 'hi'."
  stop = true
end

dialog trigger: "hi|hey" do
  say "Hi there"
  stop = false
end

dialog trigger: "restart|again" do
  restart = ask "Do you want to restart from the beginning?", expecting: [@yes, @no]
  if restart == :yes do
    invoke main
  end
end

dialog trigger: "help" do
  say "Some common interactions are:"
  say "'stop' to stop, 'hi' to reactivate, 'restart' to start again"
end

dialog trigger: "French|Dutch|German" do
  say "Sorry I only speak English"
end

# Validation

@postcode learn(input: "^\d{5}(?:[-\s]\d{4})?$")

dialog validate_postcode do
  say "Sorry, that doesn't look like a postcode. Should be something like 10001"
end

# Built in special cases

dialog __returning__ do
  random do
    say "Where were we..."
    say "Back the to subject..."
    say "Shall we..."
    say "Ok..."
    say "So..."
  end
end

dialog __unknown_location__ do
  say "Thanks for your location. Will keep it in mind next time I visit."
end

dialog __unknown__ do
  random do
    say "Sorry I don't understand"
    say "Sorry I am just a chatbot"
  end
  say "Type 'help' to get help on my capabilities "
end

@thumb_up 369239263222822

dialog(attachment: :image) do
  if attachment.metadata.sticker_id do
    if attachment.metadata.sticker_id == @thumb_up do
      say "ðŸ‘"
    else
      say "Cool sticker!"
    end
  else
    say "Thanks for the photo!"
  end
end

dialog __timeout__ do
  emit "bye bye #{user.user_id}"  # emits to a backchannel
end
-->
</div>

</body>
</html>
