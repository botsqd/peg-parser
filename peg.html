<html>
<body>
<script src = './devserver.js'></script>
<script>
function run(){

var LOG = 0
Error.stackTraceLimit=50
window.__defineSetter__('_', function(arg){
	var stack = new Error().stack || ''
	// lets collect the stack
	var st = stack.split('\n')
	var str = ''
	for(var i = 0; i < st.length; i++){
		var m = st[i].match(/at (\w+)/)
		if(m){
			if(defGrammar[m[1]]){
				if(str) str += '<'
				str += m[1]
			}
		}
	}
	console.log(str + ': '+arg.replace(/\n/g, '\\n'))
})

// GRAMMAR
var defGrammar = {
	Start   	:o=>o.zeroOrMore(o=>o.ws && o('\n')) && o.zeroOrMore(o=>o.Attribute || o.Statement),

	// optimized out:
	//Id	    :o=>o.not(o=>o('do') || o('end') || o('if')) && (o('a', 'z') || o('A', 'Z') || o('_')) && o.zeroOrMore(o=>o('a', 'z') || o('A', 'Z') || o('0', '9') || o('_')),
	//String  	:o=>o('"') && o.zeroOrMore(o=>o.inv('"')) && o('"'),
	
	IdChain     :o=>o.fold(o=>o.Id && o.zeroOrMore(o=>o('.') && o.Id)),

	PrefId      :o=>o.empty(o=>o.zeroOrOne(o=>o('!')||o('-')||o('+')) && o.ws && o.IdChain, 1),

	Number      :o=>(o.zeroOrOne(o=>o('-')) && o.oneOrMore(o=>o('0', '9')) && o.zeroOrOne(o=>o('.') && o.oneOrMore(o=>o('0', '9')))),
	Boolean     :o=>o('true') || o('false'),
	DoBlock		:o=>o('do') && o.ws && o.eat('\n') && 
				o.Statements &&
				o.ws && o('end'),

	Statements  :o=>o.zeroOrMore(o=>o.ws && o('\n')) && o.zeroOrMore(o=>o.not(o=>o('end') || o('else')) && o.Statement),

	Comment     :o=>o('#') && o.zeroOrMore(o=>o.inv('\n')),

	Statement	:o=>o.ws && o.group(o=>o.CallNoParen || o.Expression || o.Comment) && o.oneOrMore(o=>o.zeroOrMore(o=>o.ws && o.Comment) && o.ws && o.eat('\n')),
	
	Attribute	:o=>o('@') && o.Id && o.rws && o.Expression && o.oneOrMore(o=>o.ws && o.eat('\n')),
	
	Expression  :o=>o.Assign || o.Logic || o.Math || o.ExprAtom,
	ExprAtom    :o=>o.fold(o=>o.CallParen || o.If || o.DoBlock || o.List || o.String || o.Atom || o.AttribRef || o.Number || o.PrefId|| o.Boolean),
	List 		:o=>o('[') && o.ws && o.zeroOrOne(o=>o.Expression) && o.zeroOrMore(o=>o.ws && o(',') && o.ws && o.Expression) && o.ws && o(']'),

	Label       :o=>o.Id && o(':'),
	Atom        :o=>o(':') && o.Id,
	AttribRef   :o=>o('@') && o.Id,

	ParenArg    :o=>o.zeroOrOne(o=>o.Label && o.ws) && o.Expression,
	CallParen   :o=>o.IdChain && o.ws && o('(') && o.ws && o.zeroOrOne(o=>o.ParenArg) && o.zeroOrMore(o=>o.ws && o(',') && o.ws && o.ParenArg) && o.ws && o(')') && o.zeroOrOne(o=>o.ws && o.DoBlock),

	NoParenArg  :o=>o.zeroOrOne(o=>o.Label && o.ws) && o.Expression,
	CallNoParen	:o=>o.IdChain && o.rws && o.NoParenArg && o.zeroOrMore(o=>( o.group(o=>o.ws && o(',') && o.ws) ||o.rws) && o.NoParenArg),
	
	ElseBlock: 	o=>o('do') && o.ws && o.eat('\n') && 
				o.Statements &&
				o.ws && o('else') && o.ws && o.eat('\n') &&
				o.Statements &&
				o.ws && o('end'),

	If: o=>o('if') && o.rws && o.Expression && o.rws && o.group(o=>o.ElseBlock || o.DoBlock),

	Assign		:o=>o.Id && o.ws && o.group(o=>o('+=')||o('-=')||o('/=')||o('*=')||o('=')) && o.ws && (o.CallNoParen || o.Expression),

	Logic   :o=>o.fold(o=>o.Or),
	Or      :o=>o.fold(o=>o.And && o.zeroOrMore(o=>o.ws && o('||') && o.ws && o.And)),
	And     :o=>o.fold(o=>o.Cmp && o.zeroOrMore(o=>o.ws && o('&&') && o.ws && o.Cmp)),
	Cmp     :o=>o.fold(o=>o.LogicS && o.zeroOrOne(o=>o.ws && (o('<=') || o('<') || o('>=') || o('>') || o('!=') || o('==')) && o.ws && o.LogicS)),
	LogicS  :o=>o.fold(o=>o.ExprAtom || o('(') && o.ws && o.Expression && o.ws && o(')')),

	Math    :o=>o.fold(o=>o.Sum),
	Sum     :o=>o.fold(o=>o.Prod && o.zeroOrMore(o=>o.ws && (o('+') || o('-')) && o.ws  && o.Prod)),
	Prod    :o=>o.fold(o=>o.MathS && o.zeroOrMore(o=>o.ws && (o('*') || o('/')) && o.ws && o.MathS)),
	MathS   :o=>o.fold(o=>o.ExprAtom || o('(') && o.ws && o.Expression && o.ws && o(')'))

}
// Input form
var inputSource = document.getElementById('file').childNodes[1].nodeValue

function makeParser(rules) {
	
	function p(a, b, eat, inv) {
		var input = p.input
		if(p.pos > input.length) return false
		if(typeof b === 'string') { // range
			var c = input.charCodeAt(p.pos)
			var cin = c >= a.charCodeAt(0) && c <= b.charCodeAt(0)
			if(inv && !cin || !inv && cin) {
				if(!eat) p.ast.value += input.charAt(p.pos)
				if(LOG) _='[' + input.charAt(p.pos) + ']' + input.slice(p.pos + 1)
				p.pos++
				return true
			}
			if(LOG) _='!' + input.charAt(p.pos) + '!' + input.slice(p.pos + 1)
			return false
		}
		var s = ''
		for(var i = 0, pos = p.pos;i < a.length;i++,pos++){ // string match
			s += input.charAt(pos)
			var cin = input.charCodeAt(pos) !== a.charCodeAt(i)
			if(inv && !cin || !inv && cin) {
				if(LOG) _='!' + s + '!' + input.slice(p.pos + s.length)
				return false
			}
		}
		if(LOG) _='[' + s + ']' + input.slice(p.pos + s.length)
		
		if(!eat) p.ast.value += s
		if(pos > p.last) p.last = pos
		p.pos = pos
		return true
	}
	
	p.eat = function(a, b) {
		return p(a, b, true)
	}
	
	p.inv = function(a, b) {
		return p(a, b, false, true)
	}
	
	p.parse = function(input) {
		p.memoize = {}
		p.input = input
		p.pos = 0
		p.last = 0
		var ast = p.ast = {n:[]}
		p.fail = []
		p.stack = []
		p.Start
		return ast.n[0]
	}
	
	p.fold = function(fn) {
		if(fn(p)) {
			if(p.ast.n.length < 2) return 0
			return true
		}
		return false
	}
	
	p.empty = function(fn) {
		if(fn(p)) {
			if(p.ast.value.length == 0) return 0
			return true
		}
		return false
	}
	p.__defineGetter__('ws', function() {
		var input = p.input
		while(p.pos < input.length && (input.charCodeAt(p.pos) === 32 || input.charCodeAt(p.pos) === 9)){
			p.pos++
		}
		return true
	})

	p.__defineGetter__('rws', function() {
		var input = p.input
		var pos = p.pos
		while(p.pos < input.length && (input.charCodeAt(p.pos) === 32 || input.charCodeAt(p.pos) === 9)){
			p.pos++
		}
		return pos !== p.pos
	})
	
	p.__defineGetter__('Id', function() {
		var input = p.input
		var pos = p.pos
		var c1 = input.charCodeAt(p.pos)

		// check for do end or if
		var c2 = input.charCodeAt(p.pos+1)
		var c3 = input.charCodeAt(p.pos+2)
		if(c1 == 100 && c2 == 111)  return false // do
		if(c1 == 105 && c2 == 102) return false //if
		if(c1 == 101 && c2 == 110 && c3 == 100) return false // end

		if(c1 >= 65 && c1 <=90 || c1 >= 97 && c1 <= 122 || c1 == 95){
			p.pos++
			while(p.pos < input.length){
				c1 = input.charCodeAt(++p.pos)
				if(!(c1 >=48 && c1 <= 57 || c1 >= 65 && c1 <=90 || c1 >= 97 && c1 <= 122 || c1 == 95)){
					// make a node and add it.
					p.ast.n.push({
						type:'Id',
						n:[],
						value:input.slice(pos, p.pos), 
						start:pos, end:p.pos
					})
					break
				}
			}
		}
		return pos !== p.pos
	})

	p.__defineGetter__('String', function() {
		var input = p.input
		var pos = p.pos
		var ch = input.charCodeAt(p.pos)
		if(ch == 34){
			while(p.pos < input.length){
				ch = input.charCodeAt(++p.pos)
				if(ch === 34){
					p.pos++
					p.ast.n.push({
						type:'String',
						n:[],
						value:input.slice(pos, p.pos), 
						start:pos, end:p.pos
					})
					return true
				}
			}
		}
		return false
	})

	p.zeroOrMore = function(fn) { //zero or more
		while(1){
			var pos = p.pos
			if(!fn(p)){
				p.pos = pos
				break
			}
		}
		return true
	}
	
	p.oneOrMore = function(fn) { //one or more
		var c = 0
		while(1){
			var pos = p.pos
			if(!fn(p)){
				p.pos = pos
				break
			}
			c++
		}
		return c !== 0
	}
	
	p.zeroOrOne = function(fn) { //one or more
		var pos = p.pos
		if(!fn(p)){
			p.pos = pos
		}
		return true
	}
	
	p.not = function(fn, b) {
		var pos = p.pos, ret = fn(p)
		p.pos = pos
		return !ret
	}
	
	p.and = function(fn, b) {
		var pos = p.pos, ret = fn(p)
		p.pos = pos
		return ret
	}
	
	p.group = function(fn) {
		var pos = p.pos, ret = fn(p)
		if(!ret) p.pos = pos
		return ret
	}

	for(var key in rules){
		p.__defineGetter__(key, function(key) {
			
			var pos = p.pos

			var rule = rules[key]
			var parent = p.ast
			// lets check our memoize fn 
			
			// if we do the same item at the same spot, return it
			p.stack.push(key)

			var memo = p.memoize[pos]
			var mine = memo && memo[key]
			var ret
			if(!mine){
				mine = p.ast = {type:key, n:[], value:'', start:pos}
				ret = rule(p)
			}
			else{
				p.pos = mine.end
				ret = true
			}

			p.ast = parent

			if(ret === true) {
				var memo = p.memoize[mine.start] || (p.memoize[mine.start] = {})
				memo[key] = mine
				mine.end = p.pos
				parent.n.push(mine)
				parent[key] = mine
				p.stack.pop()
				return true
			}
			else if(ret === 0) {
				var sub = mine.n[0]
				if(sub) parent.n.push(mine.n[0])
				p.stack.pop()
				return true
			}
			p.fail.push(p.stack.join('/'))
			p.stack.pop()
			p.pos = pos
			return false
		}.bind(this, key))
	}
	
	return p
}


var parser = makeParser(defGrammar)
var dt = Date.now()
var bench = false
if(bench){
	var dt = Date.now()
	for(var i = 0; i <100; i++){
		var ast = parser.parse(inputSource)
	}
	console.log("Performance per parse: "+((Date.now()-dt)/100)+"ms")
}

var ast = parser.parse(inputSource)

/*
var serializeAST = {
	indentChar:'   ',
	indent:'',
	'Name': function(node){
		return node.value
	},
	'String': function(node){
		return node.value 
	},
	'Say': function(node){
		var ret = 'say'
		var n = node.n
		for(var i = 0; i < n.length; i++){
			var arg = n[i]
			ret += ' ' + this[arg.type](arg)
		}
		return ret
	},
	'Statement' : function(node){
		var arg = node.n[0]
		return this[arg.type](arg)
	},
	'Block': function(node){
		var indent = this.indent
		this.indent += this.indentChar

		var ret ='do\n'
		var n = node.n
		for(var i = 0; i < n.length; i++){
			var stmt = n[i]
			ret += this.indent + this[stmt.type](stmt) + '\n'
		}
		this.indent = indent
		ret += indent + 'end\n'
		return ret
	},
	'Dialog':function(node){
		return 'Dialog ' + this.Name(node.Name) + ' ' + this.Block(node.Block)
	}
}*/

function dumpAst(node, d){
	document.body.innerHTML += '<span>'+Array(d).join('&nbsp&nbsp&nbsp') + node.type + ':' + node.value+'</span><br/>'
	for(let i = 0;i < node.n.length;i++){
		dumpAst(node.n[i], d + 1)
	}
}
document.body.innerHTML += '<span>---- AST -----</span><br/>'

dumpAst(ast, 0)


// lets modify the name of the dialog:
//ast.Dialog.Name.value = 'myDialog'
/*
document.body.innerHTML += '<span>----- Reserialized -----<br/>'+ serializeAST.Dialog(ast.Dialog).replace(/\n/g,'<br/>').replace(/ /g,'&nbsp;')+'</span>'
*/
}
document.addEventListener('DOMContentLoaded', run)
</script>
<div id='file'>
<!--
# Settings
@delay 1
@typing_indicator 1

# Common Entities

@yes learn(input: "yes|yep|sure", label: "Yes", return: :yes)
@no learn(input: "no|nope|nah", label: "No", return: :no)

# Common Dialogs

dialog trigger: "stop|quit|end|finish" do
  say "Ok I'll shut up now. Activate me again by saying 'hi'."
  stop = true
end

dialog trigger: "hi|hey" do
  say "Hi there"
  stop = false
end

dialog trigger: "restart|again" do
  restart = ask "Do you want to restart from the beginning?", expecting: [@yes, @no]
  if restart == :yes do
    invoke main
  end
end

dialog trigger: "help" do
  say "Some common interactions are:"
  say "'stop' to stop, 'hi' to reactivate, 'restart' to start again"
end

dialog trigger: "French|Dutch|German" do
  say "Sorry I only speak English"
end

# Validation

@postcode learn(input: "^\d{5}(?:[-\s]\d{4})?$")

dialog validate_postcode do
  say "Sorry, that doesn't look like a postcode. Should be something like 10001"
end

# Built in special cases

dialog __returning__ do
  random do
    say "Where were we..."
    say "Back the to subject..."
    say "Shall we..."
    say "Ok..."
    say "So..."
  end
end

dialog __unknown_location__ do
  say "Thanks for your location. Will keep it in mind next time I visit."
end

dialog __unknown__ do
  random do
    say "Sorry I don't understand"
    say "Sorry I am just a chatbot"
  end
  say "Type 'help' to get help on my capabilities "
end

@thumb_up 369239263222822

dialog(attachment: :image) do
  if attachment.metadata.sticker_id do
    if attachment.metadata.sticker_id == @thumb_up do
      say "👍"
    else
      say "Cool sticker!"
    end
  else
    say "Thanks for the photo!"
  end
end

dialog __timeout__ do
  emit "bye bye #{user.user_id}"  # emits to a backchannel
end
-->
</div>

</body>
</html>
